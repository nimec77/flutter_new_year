// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'dont_congrats_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$DontCongratsEventTearOff {
  const _$DontCongratsEventTearOff();

// ignore: unused_element
  _CongratsChecked congratsChecked() {
    return const _CongratsChecked();
  }

// ignore: unused_element
  _ConratsUnchecked congratsUnchecked() {
    return const _ConratsUnchecked();
  }
}

/// @nodoc
// ignore: unused_element
const $DontCongratsEvent = _$DontCongratsEventTearOff();

/// @nodoc
mixin _$DontCongratsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult congratsChecked(),
    @required TResult congratsUnchecked(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult congratsChecked(),
    TResult congratsUnchecked(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult congratsChecked(_CongratsChecked value),
    @required TResult congratsUnchecked(_ConratsUnchecked value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult congratsChecked(_CongratsChecked value),
    TResult congratsUnchecked(_ConratsUnchecked value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $DontCongratsEventCopyWith<$Res> {
  factory $DontCongratsEventCopyWith(
          DontCongratsEvent value, $Res Function(DontCongratsEvent) then) =
      _$DontCongratsEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$DontCongratsEventCopyWithImpl<$Res>
    implements $DontCongratsEventCopyWith<$Res> {
  _$DontCongratsEventCopyWithImpl(this._value, this._then);

  final DontCongratsEvent _value;
  // ignore: unused_field
  final $Res Function(DontCongratsEvent) _then;
}

/// @nodoc
abstract class _$CongratsCheckedCopyWith<$Res> {
  factory _$CongratsCheckedCopyWith(
          _CongratsChecked value, $Res Function(_CongratsChecked) then) =
      __$CongratsCheckedCopyWithImpl<$Res>;
}

/// @nodoc
class __$CongratsCheckedCopyWithImpl<$Res>
    extends _$DontCongratsEventCopyWithImpl<$Res>
    implements _$CongratsCheckedCopyWith<$Res> {
  __$CongratsCheckedCopyWithImpl(
      _CongratsChecked _value, $Res Function(_CongratsChecked) _then)
      : super(_value, (v) => _then(v as _CongratsChecked));

  @override
  _CongratsChecked get _value => super._value as _CongratsChecked;
}

/// @nodoc
class _$_CongratsChecked implements _CongratsChecked {
  const _$_CongratsChecked();

  @override
  String toString() {
    return 'DontCongratsEvent.congratsChecked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CongratsChecked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult congratsChecked(),
    @required TResult congratsUnchecked(),
  }) {
    assert(congratsChecked != null);
    assert(congratsUnchecked != null);
    return congratsChecked();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult congratsChecked(),
    TResult congratsUnchecked(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (congratsChecked != null) {
      return congratsChecked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult congratsChecked(_CongratsChecked value),
    @required TResult congratsUnchecked(_ConratsUnchecked value),
  }) {
    assert(congratsChecked != null);
    assert(congratsUnchecked != null);
    return congratsChecked(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult congratsChecked(_CongratsChecked value),
    TResult congratsUnchecked(_ConratsUnchecked value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (congratsChecked != null) {
      return congratsChecked(this);
    }
    return orElse();
  }
}

abstract class _CongratsChecked implements DontCongratsEvent {
  const factory _CongratsChecked() = _$_CongratsChecked;
}

/// @nodoc
abstract class _$ConratsUncheckedCopyWith<$Res> {
  factory _$ConratsUncheckedCopyWith(
          _ConratsUnchecked value, $Res Function(_ConratsUnchecked) then) =
      __$ConratsUncheckedCopyWithImpl<$Res>;
}

/// @nodoc
class __$ConratsUncheckedCopyWithImpl<$Res>
    extends _$DontCongratsEventCopyWithImpl<$Res>
    implements _$ConratsUncheckedCopyWith<$Res> {
  __$ConratsUncheckedCopyWithImpl(
      _ConratsUnchecked _value, $Res Function(_ConratsUnchecked) _then)
      : super(_value, (v) => _then(v as _ConratsUnchecked));

  @override
  _ConratsUnchecked get _value => super._value as _ConratsUnchecked;
}

/// @nodoc
class _$_ConratsUnchecked implements _ConratsUnchecked {
  const _$_ConratsUnchecked();

  @override
  String toString() {
    return 'DontCongratsEvent.congratsUnchecked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ConratsUnchecked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult congratsChecked(),
    @required TResult congratsUnchecked(),
  }) {
    assert(congratsChecked != null);
    assert(congratsUnchecked != null);
    return congratsUnchecked();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult congratsChecked(),
    TResult congratsUnchecked(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (congratsUnchecked != null) {
      return congratsUnchecked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult congratsChecked(_CongratsChecked value),
    @required TResult congratsUnchecked(_ConratsUnchecked value),
  }) {
    assert(congratsChecked != null);
    assert(congratsUnchecked != null);
    return congratsUnchecked(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult congratsChecked(_CongratsChecked value),
    TResult congratsUnchecked(_ConratsUnchecked value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (congratsUnchecked != null) {
      return congratsUnchecked(this);
    }
    return orElse();
  }
}

abstract class _ConratsUnchecked implements DontCongratsEvent {
  const factory _ConratsUnchecked() = _$_ConratsUnchecked;
}

/// @nodoc
class _$DontCongratsStateTearOff {
  const _$DontCongratsStateTearOff();

// ignore: unused_element
  _DontCongratsState dontCongrats() {
    return const _DontCongratsState();
  }

// ignore: unused_element
  _CongratsState congrats() {
    return const _CongratsState();
  }

// ignore: unused_element
  _DeleteFailure deleteFailure() {
    return const _DeleteFailure();
  }

// ignore: unused_element
  _WriteFailure writeFailure() {
    return const _WriteFailure();
  }
}

/// @nodoc
// ignore: unused_element
const $DontCongratsState = _$DontCongratsStateTearOff();

/// @nodoc
mixin _$DontCongratsState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dontCongrats(),
    @required TResult congrats(),
    @required TResult deleteFailure(),
    @required TResult writeFailure(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dontCongrats(),
    TResult congrats(),
    TResult deleteFailure(),
    TResult writeFailure(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dontCongrats(_DontCongratsState value),
    @required TResult congrats(_CongratsState value),
    @required TResult deleteFailure(_DeleteFailure value),
    @required TResult writeFailure(_WriteFailure value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dontCongrats(_DontCongratsState value),
    TResult congrats(_CongratsState value),
    TResult deleteFailure(_DeleteFailure value),
    TResult writeFailure(_WriteFailure value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $DontCongratsStateCopyWith<$Res> {
  factory $DontCongratsStateCopyWith(
          DontCongratsState value, $Res Function(DontCongratsState) then) =
      _$DontCongratsStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$DontCongratsStateCopyWithImpl<$Res>
    implements $DontCongratsStateCopyWith<$Res> {
  _$DontCongratsStateCopyWithImpl(this._value, this._then);

  final DontCongratsState _value;
  // ignore: unused_field
  final $Res Function(DontCongratsState) _then;
}

/// @nodoc
abstract class _$DontCongratsStateCopyWith<$Res> {
  factory _$DontCongratsStateCopyWith(
          _DontCongratsState value, $Res Function(_DontCongratsState) then) =
      __$DontCongratsStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$DontCongratsStateCopyWithImpl<$Res>
    extends _$DontCongratsStateCopyWithImpl<$Res>
    implements _$DontCongratsStateCopyWith<$Res> {
  __$DontCongratsStateCopyWithImpl(
      _DontCongratsState _value, $Res Function(_DontCongratsState) _then)
      : super(_value, (v) => _then(v as _DontCongratsState));

  @override
  _DontCongratsState get _value => super._value as _DontCongratsState;
}

/// @nodoc
class _$_DontCongratsState implements _DontCongratsState {
  const _$_DontCongratsState();

  @override
  String toString() {
    return 'DontCongratsState.dontCongrats()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DontCongratsState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dontCongrats(),
    @required TResult congrats(),
    @required TResult deleteFailure(),
    @required TResult writeFailure(),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return dontCongrats();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dontCongrats(),
    TResult congrats(),
    TResult deleteFailure(),
    TResult writeFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (dontCongrats != null) {
      return dontCongrats();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dontCongrats(_DontCongratsState value),
    @required TResult congrats(_CongratsState value),
    @required TResult deleteFailure(_DeleteFailure value),
    @required TResult writeFailure(_WriteFailure value),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return dontCongrats(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dontCongrats(_DontCongratsState value),
    TResult congrats(_CongratsState value),
    TResult deleteFailure(_DeleteFailure value),
    TResult writeFailure(_WriteFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (dontCongrats != null) {
      return dontCongrats(this);
    }
    return orElse();
  }
}

abstract class _DontCongratsState implements DontCongratsState {
  const factory _DontCongratsState() = _$_DontCongratsState;
}

/// @nodoc
abstract class _$CongratsStateCopyWith<$Res> {
  factory _$CongratsStateCopyWith(
          _CongratsState value, $Res Function(_CongratsState) then) =
      __$CongratsStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$CongratsStateCopyWithImpl<$Res>
    extends _$DontCongratsStateCopyWithImpl<$Res>
    implements _$CongratsStateCopyWith<$Res> {
  __$CongratsStateCopyWithImpl(
      _CongratsState _value, $Res Function(_CongratsState) _then)
      : super(_value, (v) => _then(v as _CongratsState));

  @override
  _CongratsState get _value => super._value as _CongratsState;
}

/// @nodoc
class _$_CongratsState implements _CongratsState {
  const _$_CongratsState();

  @override
  String toString() {
    return 'DontCongratsState.congrats()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CongratsState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dontCongrats(),
    @required TResult congrats(),
    @required TResult deleteFailure(),
    @required TResult writeFailure(),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return congrats();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dontCongrats(),
    TResult congrats(),
    TResult deleteFailure(),
    TResult writeFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (congrats != null) {
      return congrats();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dontCongrats(_DontCongratsState value),
    @required TResult congrats(_CongratsState value),
    @required TResult deleteFailure(_DeleteFailure value),
    @required TResult writeFailure(_WriteFailure value),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return congrats(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dontCongrats(_DontCongratsState value),
    TResult congrats(_CongratsState value),
    TResult deleteFailure(_DeleteFailure value),
    TResult writeFailure(_WriteFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (congrats != null) {
      return congrats(this);
    }
    return orElse();
  }
}

abstract class _CongratsState implements DontCongratsState {
  const factory _CongratsState() = _$_CongratsState;
}

/// @nodoc
abstract class _$DeleteFailureCopyWith<$Res> {
  factory _$DeleteFailureCopyWith(
          _DeleteFailure value, $Res Function(_DeleteFailure) then) =
      __$DeleteFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$DeleteFailureCopyWithImpl<$Res>
    extends _$DontCongratsStateCopyWithImpl<$Res>
    implements _$DeleteFailureCopyWith<$Res> {
  __$DeleteFailureCopyWithImpl(
      _DeleteFailure _value, $Res Function(_DeleteFailure) _then)
      : super(_value, (v) => _then(v as _DeleteFailure));

  @override
  _DeleteFailure get _value => super._value as _DeleteFailure;
}

/// @nodoc
class _$_DeleteFailure implements _DeleteFailure {
  const _$_DeleteFailure();

  @override
  String toString() {
    return 'DontCongratsState.deleteFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DeleteFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dontCongrats(),
    @required TResult congrats(),
    @required TResult deleteFailure(),
    @required TResult writeFailure(),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return deleteFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dontCongrats(),
    TResult congrats(),
    TResult deleteFailure(),
    TResult writeFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (deleteFailure != null) {
      return deleteFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dontCongrats(_DontCongratsState value),
    @required TResult congrats(_CongratsState value),
    @required TResult deleteFailure(_DeleteFailure value),
    @required TResult writeFailure(_WriteFailure value),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return deleteFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dontCongrats(_DontCongratsState value),
    TResult congrats(_CongratsState value),
    TResult deleteFailure(_DeleteFailure value),
    TResult writeFailure(_WriteFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (deleteFailure != null) {
      return deleteFailure(this);
    }
    return orElse();
  }
}

abstract class _DeleteFailure implements DontCongratsState {
  const factory _DeleteFailure() = _$_DeleteFailure;
}

/// @nodoc
abstract class _$WriteFailureCopyWith<$Res> {
  factory _$WriteFailureCopyWith(
          _WriteFailure value, $Res Function(_WriteFailure) then) =
      __$WriteFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$WriteFailureCopyWithImpl<$Res>
    extends _$DontCongratsStateCopyWithImpl<$Res>
    implements _$WriteFailureCopyWith<$Res> {
  __$WriteFailureCopyWithImpl(
      _WriteFailure _value, $Res Function(_WriteFailure) _then)
      : super(_value, (v) => _then(v as _WriteFailure));

  @override
  _WriteFailure get _value => super._value as _WriteFailure;
}

/// @nodoc
class _$_WriteFailure implements _WriteFailure {
  const _$_WriteFailure();

  @override
  String toString() {
    return 'DontCongratsState.writeFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _WriteFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult dontCongrats(),
    @required TResult congrats(),
    @required TResult deleteFailure(),
    @required TResult writeFailure(),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return writeFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult dontCongrats(),
    TResult congrats(),
    TResult deleteFailure(),
    TResult writeFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (writeFailure != null) {
      return writeFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult dontCongrats(_DontCongratsState value),
    @required TResult congrats(_CongratsState value),
    @required TResult deleteFailure(_DeleteFailure value),
    @required TResult writeFailure(_WriteFailure value),
  }) {
    assert(dontCongrats != null);
    assert(congrats != null);
    assert(deleteFailure != null);
    assert(writeFailure != null);
    return writeFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult dontCongrats(_DontCongratsState value),
    TResult congrats(_CongratsState value),
    TResult deleteFailure(_DeleteFailure value),
    TResult writeFailure(_WriteFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (writeFailure != null) {
      return writeFailure(this);
    }
    return orElse();
  }
}

abstract class _WriteFailure implements DontCongratsState {
  const factory _WriteFailure() = _$_WriteFailure;
}
